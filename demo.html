<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>空间填充曲线动画</title>
    <style>
        /* 重置基础样式并设置暗色背景 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* 铺满全屏的画布 */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* 毛玻璃效果的控制面板 */
        #ui-panel {
            position: absolute;
            top: 24px;
            left: 24px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 24px;
            border-radius: 16px;
            color: #fff;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 10;
            width: 260px;
            transition: opacity 0.3s;
        }

        #ui-panel h1 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 1px;
            background: linear-gradient(90deg, #ff8a00, #e52e71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #ui-panel p {
            margin: 0 0 20px 0;
            font-size: 12px;
            color: #aaa;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ddd;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #e52e71;
        }

        /* 隐藏UI的提示 */
        #hide-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- 控制面板 -->
    <div id="ui-panel">
        <h1>希尔伯特曲线</h1>
        <p>一笔画铺满整个空间的连续分形曲线。</p>
        
        <div class="control-group">
            <label>
                <span>曲线密度 (阶数)</span>
                <span id="order-val">3</span>
            </label>
            <input type="range" id="order-slider" min="3" max="8" step="1" value="3">
        </div>

        <div class="control-group">
            <label>
                <span>绘制速度</span>
                <span id="speed-val">慢</span>
            </label>
            <input type="range" id="speed-slider" min="1" max="200" step="1" value="10">
        </div>

        <div class="control-group">
            <label>
                <span>起点数量 (区域数)</span>
                <span id="count-val">4</span>
            </label>
            <input type="range" id="count-slider" min="1" max="32" step="1" value="4">
        </div>

        <div class="control-group">
            <label>
                <span>线条粗细</span>
                <span id="thickness-val">1.0x</span>
            </label>
            <input type="range" id="thickness-slider" min="0.2" max="5.0" step="0.1" value="1.0">
        </div>
    </div>

    <div id="hide-hint">双击屏幕隐藏/显示控制面板</div>

    <!-- 渲染画布：细线与发光棋子同处一层 -->
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const orderSlider = document.getElementById('order-slider');
        const speedSlider = document.getElementById('speed-slider');
        const countSlider = document.getElementById('count-slider');
        const thicknessSlider = document.getElementById('thickness-slider');
        
        const orderVal = document.getElementById('order-val');
        const speedVal = document.getElementById('speed-val');
        const countVal = document.getElementById('count-val');
        const thicknessVal = document.getElementById('thickness-val');
        const uiPanel = document.getElementById('ui-panel');

        let width, height;
        let pointsArrays = [];
        let currentIndex = 0;
        let animationId;
        
        // 核心参数
        let order = parseInt(orderSlider.value);
        let speed = parseInt(speedSlider.value);
        let count = parseInt(countSlider.value);
        let thicknessMultiplier = parseFloat(thicknessSlider.value);

        // 状态机: DRAWING (绘制中) -> WAITING (等待) -> FADING (淡出)
        let state = 'DRAWING'; 
        let waitFrames = 0;
        let fadeFrames = 0;

        // 自动计算并划分屏幕为 N 个区域 (允许长宽不一致，保证区域总数严格等于设定值)
        function partitionSpace(w, h, n) {
            let cols = Math.ceil(Math.sqrt(n * w / h));
            let rows = Math.ceil(n / cols);
            let rects = [];
            let cellH = h / rows;
            let currentCount = 0;
            
            for (let r = 0; r < rows; r++) {
                let itemsInRow = (r === rows - 1) ? (n - currentCount) : cols;
                let cellW = w / itemsInRow;
                for (let c = 0; c < itemsInRow; c++) {
                    rects.push({
                        x: c * cellW,
                        y: r * cellH,
                        w: cellW,
                        h: cellH
                    });
                    currentCount++;
                    if (currentCount >= n) break;
                }
            }
            return rects;
        }

        // 初始化/重置画布和曲线
        function initCurve() {
            if (animationId) cancelAnimationFrame(animationId);
            
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            // 划分屏幕区域，严格等于设定的 count
            const rects = partitionSpace(width, height, count);
            countVal.innerText = count;

            pointsArrays = [];
            for (let i = 0; i < count; i++) {
                pointsArrays.push([]);
            }
            
            currentIndex = 0;
            state = 'DRAWING';
            waitFrames = 0;
            fadeFrames = 0;
            ctx.clearRect(0, 0, width, height);

            // 全局目标间距，用于校准所有区域的密度
            const targetSpacing = Math.min(width, height) / Math.pow(2, order);

            // 为每个区域独立生成自适应阶数的曲线
            for (let i = 0; i < count; i++) {
                const rect = rects[i];
                
                // 【核心改进】根据区域物理尺寸，动态计算适合该区域的独立阶数，保证全局效果一致
                const effectiveSize = Math.sqrt(rect.w * rect.h);
                let cellOrder = Math.round(Math.log2(effectiveSize / targetSpacing));
                cellOrder = Math.max(1, Math.min(cellOrder, 9)); // 限制范围防崩溃

                // 获取纯逻辑坐标下的希尔伯特点集
                const logicalPts = getLogicalHilbert(cellOrder);

                // 映射到物理矩形，并交替改变生长的起始角落
                const startCorner = i % 4;
                for (let pt of logicalPts) {
                    let px = pt.x;
                    let py = pt.y;
                    
                    if (startCorner === 1) { px = 1 - pt.x; }
                    else if (startCorner === 2) { px = 1 - pt.x; py = 1 - pt.y; }
                    else if (startCorner === 3) { py = 1 - pt.y; }
                    
                    pointsArrays[i].push({
                        x: rect.x + px * rect.w,
                        y: rect.y + py * rect.h
                    });
                }
            }

            // 使用全局目标间距动态计算基准线宽
            ctx.lineWidth = Math.max(0.5, targetSpacing * 0.15) * thicknessMultiplier; 
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            animate();
        }

        // 纯逻辑坐标下的希尔伯特曲线生成 (坐标范围 0~1)
        // 消除传统分形算法在矩形中翻转造成的“局部密度混乱”
        function getLogicalHilbert(n) {
            let pts = [];
            function recurse(x, y, xi, xj, yi, yj, step) {
                if (step <= 0) {
                    pts.push({ x: x + (xi + yi) / 2, y: y + (xj + yj) / 2 });
                    return;
                }
                recurse(x, y, yi / 2, yj / 2, xi / 2, xj / 2, step - 1);
                recurse(x + xi / 2, y + xj / 2, xi / 2, xj / 2, yi / 2, yj / 2, step - 1);
                recurse(x + xi / 2 + yi / 2, y + xj / 2 + yj / 2, xi / 2, xj / 2, yi / 2, yj / 2, step - 1);
                recurse(x + xi / 2 + yi, y + xj / 2 + yj, -yi / 2, -yj / 2, -xi / 2, -xj / 2, step - 1);
            }
            recurse(0, 0, 1, 0, 0, 1, n);
            return pts;
        }

        // 主渲染动画循环
        function animate() {
            if (state === 'DRAWING') {
                // 每一帧绘制 speed 条线段
                for (let i = 0; i < speed; i++) {
                    
                    // 【核心改进】检查是否所有区域都已经绘制完毕 (因为各区域阶数不同，包含的点数可能不同)
                    let allDone = true;
                    for (let j = 0; j < count; j++) {
                        if (currentIndex < pointsArrays[j].length - 1) {
                            allDone = false;
                            break;
                        }
                    }
                    if (allDone) {
                        state = 'WAITING'; // 全部画完才进入等待状态
                        break;
                    }

                    // 1. 绘制带有亮度渐变的连线 (起点暗，终点/拐点亮)
                    ctx.shadowBlur = 0;
                    
                    for (let j = 0; j < count; j++) {
                        // 如果当前区域已经画完，则静默等待其他区域
                        if (currentIndex >= pointsArrays[j].length - 1) continue;

                        const p1 = pointsArrays[j][currentIndex];
                        const p2 = pointsArrays[j][currentIndex + 1];
                        
                        // 为当前这条线段创建从起点(p1)到终点(p2)的线性渐变
                        const lineGradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                        lineGradient.addColorStop(0, 'rgba(200, 100, 0, 0.05)'); 
                        lineGradient.addColorStop(1, 'rgba(255, 190, 0, 0.7)');  
                        
                        ctx.strokeStyle = lineGradient;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }

                    // 2. 绘制用明暗渐变表现的高亮拐点
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.shadowBlur = 0; 

                    for (let j = 0; j < count; j++) {
                        if (currentIndex >= pointsArrays[j].length - 1) continue;

                        const p2 = pointsArrays[j][currentIndex + 1];
                        
                        // 光晕的辐射半径稍微加大
                        const radius = Math.max(2.5, ctx.lineWidth * 5);
                        
                        const gradient = ctx.createRadialGradient(p2.x, p2.y, 0, p2.x, p2.y, radius);
                        gradient.addColorStop(0, 'rgba(255, 240, 180, 1)');     
                        gradient.addColorStop(0.2, 'rgba(255, 160, 0, 0.5)');   
                        gradient.addColorStop(1, 'rgba(255, 160, 0, 0)');       
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p2.x, p2.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.globalCompositeOperation = 'source-over';
                    currentIndex++;
                }
            } 
            else if (state === 'WAITING') {
                // 曲线铺满后停顿展示 (约2秒 at 60fps)
                waitFrames++;
                if (waitFrames > 120) {
                    state = 'FADING';
                    ctx.shadowBlur = 0; // 淡出时关闭发光以提高性能
                }
            } 
            else if (state === 'FADING') {
                // 优雅地淡出屏幕
                ctx.fillStyle = 'rgba(5, 5, 5, 0.08)';
                ctx.fillRect(0, 0, width, height);
                fadeFrames++;
                if (fadeFrames > 60) {
                    initCurve(); // 彻底淡出后重新开始
                    return; 
                }
            }

            animationId = requestAnimationFrame(animate);
        }

        // --- 事件监听器 ---

        // 窗口大小调整
        window.addEventListener('resize', () => {
            // 延迟一点触发，避免拖拽边缘时过度频繁计算
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(initCurve, 200);
        });

        // 密度滑块
        orderSlider.addEventListener('input', (e) => {
            order = parseInt(e.target.value);
            orderVal.innerText = order;
            initCurve(); // 更改密度需要重新计算路径
        });

        // 速度滑块
        speedSlider.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            if(speed < 30) speedVal.innerText = '慢';
            else if (speed < 100) speedVal.innerText = '中';
            else speedVal.innerText = '快';
        });

        // 起点数量滑块
        countSlider.addEventListener('input', (e) => {
            count = parseInt(e.target.value);
            initCurve(); // 更新 UI 逻辑已移入 initCurve 内部
        });

        // 粗细滑块
        thicknessSlider.addEventListener('input', (e) => {
            thicknessMultiplier = parseFloat(e.target.value);
            thicknessVal.innerText = thicknessMultiplier.toFixed(1) + 'x';
            initCurve(); // 更改粗细需要重新计算并绘制
        });

        // 双击隐藏/显示UI以沉浸式观看
        window.addEventListener('dblclick', () => {
            if (uiPanel.style.opacity === '0') {
                uiPanel.style.opacity = '1';
                uiPanel.style.pointerEvents = 'auto';
            } else {
                uiPanel.style.opacity = '0';
                uiPanel.style.pointerEvents = 'none';
            }
        });

        // 启动
        initCurve();
    </script>
</body>
</html>