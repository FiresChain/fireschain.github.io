<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js 墙角 Demo</title>
  <style>
    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background:
        radial-gradient(80% 70% at 50% 22%, #1e3f78 0%, #0b1731 45%, #050a16 100%);
    }

    #scene-root {
      position: absolute;
      inset: 0;
    }

    #scene-root canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .tag {
      position: absolute;
      top: 16px;
      left: 16px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(8, 12, 20, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #dce6ff;
      font-size: 13px;
      z-index: 5;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="scene-root"></div>
  <div class="tag">Three.js 墙角基础场景（左墙 + 后墙 + 地面）</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    const root = document.getElementById('scene-root');

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x050a16, 9, 18);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 40);
    camera.position.set(4.6, 2.1, 6.4);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    root.appendChild(renderer.domElement);

    const textureLoader = new THREE.TextureLoader();
    const wallTexture = textureLoader.load('wall.jpg');
    wallTexture.colorSpace = THREE.SRGBColorSpace;
    wallTexture.wrapS = THREE.RepeatWrapping;
    wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(4.8, 3.6);
    wallTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const groundTexture = textureLoader.load('ground.jpg?v=2');
    groundTexture.colorSpace = THREE.SRGBColorSpace;
    groundTexture.wrapS = THREE.RepeatWrapping;
    groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(2, 2);
    groundTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const leftPaintingTexture = textureLoader.load('left_picture-removebg-preview.png');
    leftPaintingTexture.colorSpace = THREE.SRGBColorSpace;
    leftPaintingTexture.wrapS = THREE.ClampToEdgeWrapping;
    leftPaintingTexture.wrapT = THREE.ClampToEdgeWrapping;
    leftPaintingTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const rightPaintingTexture = textureLoader.load('right_picture-removebg-preview.png');
    rightPaintingTexture.colorSpace = THREE.SRGBColorSpace;
    rightPaintingTexture.wrapS = THREE.ClampToEdgeWrapping;
    rightPaintingTexture.wrapT = THREE.ClampToEdgeWrapping;
    rightPaintingTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const ellipsisTexture = textureLoader.load('icon-removebg-preview.png');
    ellipsisTexture.colorSpace = THREE.SRGBColorSpace;
    ellipsisTexture.wrapS = THREE.ClampToEdgeWrapping;
    ellipsisTexture.wrapT = THREE.ClampToEdgeWrapping;
    ellipsisTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const room = new THREE.Group();
    scene.add(room);

    const amb = new THREE.AmbientLight(0xffffff, 0.62);
    scene.add(amb);

    const key = new THREE.DirectionalLight(0xbfd8ff, 1.2);
    key.position.set(5, 5, 4);
    scene.add(key);

    const fill = new THREE.PointLight(0x4e7cc4, 1.05, 16, 2);
    fill.position.set(0.2, 1.4, 0.3);
    room.add(fill);

    const wallMatBack = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: wallTexture,
      roughness: 0.92,
      metalness: 0.04
    });

    const wallMatLeft = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: wallTexture,
      roughness: 0.92,
      metalness: 0.04
    });

    // 外延墙体使用纯黑，避免“贴纸感”
    const wallMatOuter = new THREE.MeshBasicMaterial({
      color: 0x000000,
      side: THREE.DoubleSide
    });

    const floorMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: groundTexture,
      roughness: 0.94,
      metalness: 0.02
    });

    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(8, 4.8), wallMatBack);
    backWall.position.set(0, 0.4, -4);
    room.add(backWall);

    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(8, 4.8), wallMatLeft);
    leftWall.position.set(-4, 0.4, 0);
    leftWall.rotation.y = Math.PI / 2;
    room.add(leftWall);

    // 外延房间：墙和地面向墙角外扩展一倍
    // 外延墙略微重叠，避免墙角出现缝隙
    const backWallOuter = new THREE.Mesh(new THREE.PlaneGeometry(16.3, 9.6), wallMatOuter);
    backWallOuter.position.set(4.02, 0.4, -4.09);
    room.add(backWallOuter);

    const leftWallOuter = new THREE.Mesh(new THREE.PlaneGeometry(16.3, 9.6), wallMatOuter);
    leftWallOuter.position.set(-4.09, 0.4, 4.02);
    leftWallOuter.rotation.y = Math.PI / 2;
    room.add(leftWallOuter);

    // 角柱封缝，彻底遮住墙角交界线
    const cornerSeal = new THREE.Mesh(new THREE.BoxGeometry(0.22, 9.6, 0.22), wallMatOuter);
    cornerSeal.position.set(-4.09, 0.4, -4.09);
    room.add(cornerSeal);

    // 地板同样分层：内地板贴图，外延区域纯黑
    const floorOuter = new THREE.Mesh(new THREE.PlaneGeometry(16.4, 16.4), wallMatOuter);
    floorOuter.rotation.x = -Math.PI / 2;
    floorOuter.position.set(4, -2.03, 4);
    room.add(floorOuter);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(8.2, 8.2), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(0, -2.0, 0);
    room.add(floor);

    function addLittleFigure() {
      const figure = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({
        color: 0x1f2735,
        roughness: 0.58,
        metalness: 0.12
      });

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.16, 20, 20), mat);
      head.position.y = 0.62;
      figure.add(head);

      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.165, 0.46, 18), mat);
      torso.position.y = 0.30;
      figure.add(torso);

      // 正面标记，让“朝向”有明显视觉
      const chest = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.16, 0.04),
        new THREE.MeshStandardMaterial({ color: 0x1a2331, roughness: 0.5, metalness: 0.2 })
      );
      chest.position.set(0, 0.30, 0.12);
      figure.add(chest);

      const legGeo = new THREE.CylinderGeometry(0.055, 0.055, 0.34, 12);
      const legL = new THREE.Mesh(legGeo, mat);
      const legR = new THREE.Mesh(legGeo, mat);
      legL.position.set(-0.07, 0.0, 0);
      legR.position.set(0.07, 0.0, 0);
      figure.add(legL);
      figure.add(legR);

      const armGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.28, 12);
      const armL = new THREE.Mesh(armGeo, mat);
      const armR = new THREE.Mesh(armGeo, mat);
      armL.position.set(-0.19, 0.28, 0);
      armR.position.set(0.19, 0.28, 0);
      armL.rotation.z = -0.42;
      armR.rotation.z = 0.42;
      figure.add(armL);
      figure.add(armR);

      figure.position.set(0.15, -1.83, -0.9);
      figure.scale.setScalar(1.35);
      room.add(figure);

      const shadow = new THREE.Mesh(
        new THREE.CircleGeometry(0.28, 32),
        new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.28, depthWrite: false })
      );
      shadow.rotation.x = -Math.PI / 2;
      shadow.position.set(0.15, -1.995, -0.9);
      room.add(shadow);

      // 头顶省略号，支持点击但不触发业务动作
      const bubble = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: ellipsisTexture,
          transparent: true,
          depthWrite: false
        })
      );
      bubble.scale.set(0.95, 0.66, 1);
      bubble.position.set(0, 1.38, 0.02);
      bubble.name = 'ellipsis-bubble';
      figure.add(bubble);

      // 面朝墙角（左后角）
      const cornerTarget = new THREE.Vector3(-4, figure.position.y + 0.25, -4);
      figure.lookAt(cornerTarget);

      return { figure, bubble };
    }

    const littleFigure = addLittleFigure();
    const interactiveTargets = [littleFigure.bubble];
    const raycaster = new THREE.Raycaster();
    const pointerNdc = new THREE.Vector2();

    function addFramedPainting(parentWall, texture, width, height, x, y) {
      const frame = new THREE.Mesh(
        new THREE.PlaneGeometry(width + 0.16, height + 0.16),
        new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.7,
          metalness: 0.2
        })
      );
      frame.position.set(x, y, 0.01);
      parentWall.add(frame);

      const painting = new THREE.Mesh(
        new THREE.PlaneGeometry(width, height),
        new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: texture,
          roughness: 0.56,
          metalness: 0.06,
          emissive: 0x101010,
          emissiveIntensity: 0.25
        })
      );
      painting.position.set(x, y, 0.02);
      parentWall.add(painting);
      return { frame, painting };
    }

    // 左墙挂画
    const leftPaintingMesh = addFramedPainting(leftWall, leftPaintingTexture, 2.95, 2.38, 0.25, 0.5);
    // 后墙挂画
    const backPaintingMesh = addFramedPainting(backWall, rightPaintingTexture, 3.2, 2.38, 1.15, 0.5);

    function addPaintingSpotlight(parentWall, targetX, targetY, color = 0xfff0cf) {
      const spot = new THREE.SpotLight(color, 1.8, 10, Math.PI / 7, 0.32, 1.2);
      spot.position.set(targetX, targetY + 1.0, 1.2);
      const target = new THREE.Object3D();
      target.position.set(targetX, targetY, 0.02);
      parentWall.add(target);
      spot.target = target;
      parentWall.add(spot);
    }

    addPaintingSpotlight(leftWall, 0.25, 0.5);
    addPaintingSpotlight(backWall, 1.15, 0.5);

    const figureTopLight = new THREE.PointLight(0xe6f2ff, 1.3, 5.5, 2);
    figureTopLight.position.set(
      littleFigure.figure.position.x + 0.05,
      littleFigure.figure.position.y + 1.45,
      littleFigure.figure.position.z + 0.2
    );
    room.add(figureTopLight);

    function addEdgeGlow(mesh, color) {
      const edges = new THREE.EdgesGeometry(mesh.geometry);
      const line = new THREE.LineSegments(
        edges,
        new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.32 })
      );
      line.position.copy(mesh.position);
      line.rotation.copy(mesh.rotation);
      room.add(line);
    }

    addEdgeGlow(backWall, 0xb9ccf1);
    addEdgeGlow(leftWall, 0xb9ccf1);

    const floorGrid = new THREE.GridHelper(8.2, 20, 0x6d8ec8, 0x2a3852);
    floorGrid.position.y = -1.994;
    floorGrid.material.opacity = 0.06;
    floorGrid.material.transparent = true;
    room.add(floorGrid);

    const originGuide = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, -2, 0),
        new THREE.Vector3(0, 2.3, 0)
      ]),
      new THREE.LineBasicMaterial({ color: 0x6fa7ff, transparent: true, opacity: 0.38 })
    );
    room.add(originGuide);

    // --- 墙面曲线（demo 同款逻辑与样式） ---
    const wallCurveFaces = [];
    const wallCurveOrder = 4;
    const wallCurveSpeed = 16;
    const wallCurveThicknessMultiplier = 1.0;
    let wallCurveIndex = 0;
    let wallCurveState = 'DRAWING';
    let wallCurveWaitFrames = 0;
    let wallCurveFadeFrames = 0;

    function createWallCurveFace(parentWall, wallWidth, wallHeight, options = {}) {
      const {
        extendW = 1.22,
        extendH = 1.08,
        seamSide = 'left',
        anchorUV = { x: 0.04, y: 0.62 },
        zOffset = -0.045,
        orderBias = 0
      } = options;

      const canvas = document.createElement('canvas');
      canvas.width = 1200;
      canvas.height = 720;
      const ctx = canvas.getContext('2d');

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;

      const mat = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.95,
        depthWrite: false,
        depthTest: true,
        side: THREE.DoubleSide
      });

      const drawWidth = wallWidth * extendW;
      const drawHeight = wallHeight * extendH;
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(drawWidth, drawHeight), mat);
      // 曲线层放在墙后面（最下层）
      mesh.position.z = zOffset;
      mesh.renderOrder = -30;
      const seamOffset = (drawWidth - wallWidth) * 0.5;
      // 保持墙角接缝侧对齐：left=固定左边；right=固定右边
      if (seamSide === 'none') {
        mesh.position.x = 0;
      } else {
        mesh.position.x = seamSide === 'right' ? -seamOffset : seamOffset;
      }
      parentWall.add(mesh);

      wallCurveFaces.push({
        ctx,
        texture,
        width: canvas.width,
        height: canvas.height,
        points: [],
        anchorUV,
        orderBias
      });
    }

    // demo 同款希尔伯特逻辑
    function getLogicalHilbert(n) {
      const pts = [];
      function recurse(x, y, xi, xj, yi, yj, step) {
        if (step <= 0) {
          pts.push({ x: x + (xi + yi) / 2, y: y + (xj + yj) / 2 });
          return;
        }
        recurse(x, y, yi / 2, yj / 2, xi / 2, xj / 2, step - 1);
        recurse(x + xi / 2, y + xj / 2, xi / 2, xj / 2, yi / 2, yj / 2, step - 1);
        recurse(x + xi / 2 + yi / 2, y + xj / 2 + yj / 2, xi / 2, xj / 2, yi / 2, yj / 2, step - 1);
        recurse(x + xi / 2 + yi, y + xj / 2 + yj, -yi / 2, -yj / 2, -xi / 2, -xj / 2, step - 1);
      }
      recurse(0, 0, 1, 0, 0, 1, n);
      return pts;
    }

    function chooseWallCurvePoints(logicalPts, face, marginX, marginY, drawW, drawH) {
      const variants = [
        [false, false, false],
        [true, false, false],
        [false, true, false],
        [true, true, false],
        [false, false, true],
        [true, false, true],
        [false, true, true],
        [true, true, true]
      ];

      const target = {
        x: marginX + face.anchorUV.x * drawW,
        y: marginY + face.anchorUV.y * drawH
      };

      let best = null;
      let bestDist = Number.POSITIVE_INFINITY;

      for (const [flipX, flipY, reverse] of variants) {
        const mapped = logicalPts.map((pt) => {
          const u = flipX ? 1 - pt.x : pt.x;
          const v = flipY ? 1 - pt.y : pt.y;
          return {
            x: marginX + u * drawW,
            y: marginY + v * drawH
          };
        });
        if (reverse) mapped.reverse();

        const dx = mapped[0].x - target.x;
        const dy = mapped[0].y - target.y;
        const dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          best = mapped;
        }
      }
      return best || [];
    }

    function rebuildWallCurves() {
      wallCurveIndex = 0;
      wallCurveState = 'DRAWING';
      wallCurveWaitFrames = 0;
      wallCurveFadeFrames = 0;

      const targetSpacing = Math.min(window.innerWidth, window.innerHeight) / Math.pow(2, wallCurveOrder);

      wallCurveFaces.forEach((face) => {
        const marginX = face.width * 0.06;
        const marginY = face.height * 0.08;
        const drawW = face.width - marginX * 2;
        const drawH = face.height - marginY * 2;

        const effectiveSize = Math.sqrt(drawW * drawH);
        let cellOrder = Math.round(Math.log2(effectiveSize / Math.max(1, targetSpacing)));
        cellOrder += face.orderBias || 0;
        cellOrder = Math.max(1, Math.min(cellOrder, 9));

        const logicalPts = getLogicalHilbert(cellOrder);
        face.points = chooseWallCurvePoints(logicalPts, face, marginX, marginY, drawW, drawH);

        face.ctx.clearRect(0, 0, face.width, face.height);
        face.ctx.lineWidth = Math.max(0.5, targetSpacing * 0.15) * wallCurveThicknessMultiplier;
        face.ctx.lineCap = 'round';
        face.ctx.lineJoin = 'round';
        face.texture.needsUpdate = true;
      });
    }

    function drawWallCurveStep(face, index) {
      if (index >= face.points.length - 1) return;

      const p1 = face.points[index];
      const p2 = face.points[index + 1];
      const ctx = face.ctx;

      const lineGradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
      lineGradient.addColorStop(0, 'rgba(200, 100, 0, 0.05)');
      lineGradient.addColorStop(1, 'rgba(255, 190, 0, 0.7)');

      ctx.strokeStyle = lineGradient;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();

      ctx.globalCompositeOperation = 'lighter';
      const radius = Math.max(2.5, ctx.lineWidth * 5);
      const glow = ctx.createRadialGradient(p2.x, p2.y, 0, p2.x, p2.y, radius);
      glow.addColorStop(0, 'rgba(255, 240, 180, 1)');
      glow.addColorStop(0.2, 'rgba(255, 160, 0, 0.5)');
      glow.addColorStop(1, 'rgba(255, 160, 0, 0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(p2.x, p2.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    function animateWallCurves() {
      if (wallCurveState === 'DRAWING') {
        for (let i = 0; i < wallCurveSpeed; i += 1) {
          let allDone = true;
          for (let j = 0; j < wallCurveFaces.length; j += 1) {
            if (wallCurveIndex < wallCurveFaces[j].points.length - 1) {
              allDone = false;
              break;
            }
          }
          if (allDone) {
            wallCurveState = 'WAITING';
            break;
          }

          wallCurveFaces.forEach((face) => drawWallCurveStep(face, wallCurveIndex));
          wallCurveIndex += 1;
        }
      } else if (wallCurveState === 'WAITING') {
        wallCurveWaitFrames += 1;
        if (wallCurveWaitFrames > 120) {
          wallCurveState = 'FADING';
        }
      } else if (wallCurveState === 'FADING') {
        wallCurveFaces.forEach((face) => {
          face.ctx.fillStyle = 'rgba(5, 5, 5, 0.08)';
          face.ctx.fillRect(0, 0, face.width, face.height);
        });
        wallCurveFadeFrames += 1;
        if (wallCurveFadeFrames > 60) {
          rebuildWallCurves();
          return;
        }
      }

      wallCurveFaces.forEach((face) => {
        face.texture.needsUpdate = true;
      });
    }

    createWallCurveFace(leftWall, 8, 4.8, {
      extendW: 2.0,
      extendH: 2.0,
      seamSide: 'right',
      anchorUV: { x: 0.96, y: 0.62 }
    });
    createWallCurveFace(backWall, 8, 4.8, {
      extendW: 2.0,
      extendH: 2.0,
      seamSide: 'left',
      anchorUV: { x: 0.035, y: 0.62 }
    });
    createWallCurveFace(floorOuter, 16.4, 16.4, {
      extendW: 1.0,
      extendH: 1.0,
      seamSide: 'none',
      anchorUV: { x: 0.03, y: 0.04 },
      zOffset: 0.012,
      orderBias: 1
    });
    rebuildWallCurves();

    const camTarget = new THREE.Vector3(0, -0.05, -0.8);
    let yaw = 0.62;
    let pitch = 0.22;
    let radius = 8.05;
    let dragging = false;
    let lastX = 0;
    let lastY = 0;
    let downX = 0;
    let downY = 0;
    let clickCandidate = null;

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function updateCameraPose() {
      const cp = Math.cos(pitch);
      camera.position.set(
        camTarget.x + radius * Math.sin(yaw) * cp,
        camTarget.y + radius * Math.sin(pitch),
        camTarget.z + radius * Math.cos(yaw) * cp
      );
      camera.lookAt(camTarget);
    }

    function setPointerNdcFromEvent(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointerNdc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointerNdc.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function pickInteractive(e) {
      setPointerNdcFromEvent(e);
      raycaster.setFromCamera(pointerNdc, camera);
      const hits = raycaster.intersectObjects(interactiveTargets, true);
      return hits.length > 0 ? hits[0].object : null;
    }

    function updatePointerCursor(e) {
      const hit = pickInteractive(e);
      if (hit) {
        renderer.domElement.style.cursor = 'pointer';
      } else if (dragging) {
        renderer.domElement.style.cursor = 'grabbing';
      } else {
        renderer.domElement.style.cursor = 'grab';
      }
      return hit;
    }

    renderer.domElement.addEventListener('pointerdown', (e) => {
      downX = e.clientX;
      downY = e.clientY;
      clickCandidate = pickInteractive(e);

      if (clickCandidate) {
        dragging = false;
        renderer.domElement.style.cursor = 'pointer';
        return;
      }

      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
      renderer.domElement.style.cursor = 'grabbing';
    });

    renderer.domElement.addEventListener('pointermove', (e) => {
      updatePointerCursor(e);
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      yaw = clamp(yaw - dx * 0.005, -1.3, 0.6);
      pitch = clamp(pitch - dy * 0.004, -0.15, 0.72);
    });

    function stopDrag() {
      dragging = false;
      renderer.domElement.style.cursor = 'grab';
    }

    renderer.domElement.addEventListener('pointerup', (e) => {
      const moveDistance = Math.hypot(e.clientX - downX, e.clientY - downY);
      if (clickCandidate && moveDistance < 6) {
        const hit = pickInteractive(e);
        if (hit) {
          // 可点击，但无业务行为
        }
      }
      clickCandidate = null;
      stopDrag();
    });
    renderer.domElement.addEventListener('pointercancel', stopDrag);
    renderer.domElement.addEventListener('pointerleave', stopDrag);

    renderer.domElement.addEventListener(
      'wheel',
      (e) => {
        e.preventDefault();
        radius = clamp(radius + e.deltaY * 0.008, 5.0, 12.0);
      },
      { passive: false }
    );

    function animate() {
      requestAnimationFrame(animate);
      animateWallCurves();
      updateCameraPose();
      renderer.render(scene, camera);
    }

    updateCameraPose();
    renderer.domElement.style.cursor = 'grab';
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      rebuildWallCurves();
      updateCameraPose();
    });
  </script>
</body>
</html>
